// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `comic.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:ComicChapterDetail)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComicChapterDetail {
    // message fields
    // @@protoc_insertion_point(field:ComicChapterDetail.chapterId)
    pub chapterId: i64,
    // @@protoc_insertion_point(field:ComicChapterDetail.comicId)
    pub comicId: i64,
    // @@protoc_insertion_point(field:ComicChapterDetail.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:ComicChapterDetail.chapterOrder)
    pub chapterOrder: i32,
    // @@protoc_insertion_point(field:ComicChapterDetail.direction)
    pub direction: i32,
    // @@protoc_insertion_point(field:ComicChapterDetail.pageUrl)
    pub pageUrl: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ComicChapterDetail.picnum)
    pub picnum: i32,
    // @@protoc_insertion_point(field:ComicChapterDetail.pageUrlHD)
    pub pageUrlHD: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ComicChapterDetail.commentCount)
    pub commentCount: i32,
    // special fields
    // @@protoc_insertion_point(special_field:ComicChapterDetail.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComicChapterDetail {
    fn default() -> &'a ComicChapterDetail {
        <ComicChapterDetail as ::protobuf::Message>::default_instance()
    }
}

impl ComicChapterDetail {
    pub fn new() -> ComicChapterDetail {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chapterId",
            |m: &ComicChapterDetail| { &m.chapterId },
            |m: &mut ComicChapterDetail| { &mut m.chapterId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comicId",
            |m: &ComicChapterDetail| { &m.comicId },
            |m: &mut ComicChapterDetail| { &mut m.comicId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &ComicChapterDetail| { &m.title },
            |m: &mut ComicChapterDetail| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chapterOrder",
            |m: &ComicChapterDetail| { &m.chapterOrder },
            |m: &mut ComicChapterDetail| { &mut m.chapterOrder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &ComicChapterDetail| { &m.direction },
            |m: &mut ComicChapterDetail| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pageUrl",
            |m: &ComicChapterDetail| { &m.pageUrl },
            |m: &mut ComicChapterDetail| { &mut m.pageUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "picnum",
            |m: &ComicChapterDetail| { &m.picnum },
            |m: &mut ComicChapterDetail| { &mut m.picnum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pageUrlHD",
            |m: &ComicChapterDetail| { &m.pageUrlHD },
            |m: &mut ComicChapterDetail| { &mut m.pageUrlHD },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "commentCount",
            |m: &ComicChapterDetail| { &m.commentCount },
            |m: &mut ComicChapterDetail| { &mut m.commentCount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComicChapterDetail>(
            "ComicChapterDetail",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComicChapterDetail {
    const NAME: &'static str = "ComicChapterDetail";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chapterId = is.read_int64()?;
                },
                16 => {
                    self.comicId = is.read_int64()?;
                },
                26 => {
                    self.title = is.read_string()?;
                },
                32 => {
                    self.chapterOrder = is.read_int32()?;
                },
                40 => {
                    self.direction = is.read_int32()?;
                },
                50 => {
                    self.pageUrl.push(is.read_string()?);
                },
                56 => {
                    self.picnum = is.read_int32()?;
                },
                66 => {
                    self.pageUrlHD.push(is.read_string()?);
                },
                72 => {
                    self.commentCount = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.chapterId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.chapterId);
        }
        if self.comicId != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.comicId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.title);
        }
        if self.chapterOrder != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.chapterOrder);
        }
        if self.direction != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.direction);
        }
        for value in &self.pageUrl {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if self.picnum != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.picnum);
        }
        for value in &self.pageUrlHD {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if self.commentCount != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.commentCount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.chapterId != 0 {
            os.write_int64(1, self.chapterId)?;
        }
        if self.comicId != 0 {
            os.write_int64(2, self.comicId)?;
        }
        if !self.title.is_empty() {
            os.write_string(3, &self.title)?;
        }
        if self.chapterOrder != 0 {
            os.write_int32(4, self.chapterOrder)?;
        }
        if self.direction != 0 {
            os.write_int32(5, self.direction)?;
        }
        for v in &self.pageUrl {
            os.write_string(6, &v)?;
        };
        if self.picnum != 0 {
            os.write_int32(7, self.picnum)?;
        }
        for v in &self.pageUrlHD {
            os.write_string(8, &v)?;
        };
        if self.commentCount != 0 {
            os.write_int32(9, self.commentCount)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComicChapterDetail {
        ComicChapterDetail::new()
    }

    fn clear(&mut self) {
        self.chapterId = 0;
        self.comicId = 0;
        self.title.clear();
        self.chapterOrder = 0;
        self.direction = 0;
        self.pageUrl.clear();
        self.picnum = 0;
        self.pageUrlHD.clear();
        self.commentCount = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComicChapterDetail {
        static instance: ComicChapterDetail = ComicChapterDetail {
            chapterId: 0,
            comicId: 0,
            title: ::std::string::String::new(),
            chapterOrder: 0,
            direction: 0,
            pageUrl: ::std::vec::Vec::new(),
            picnum: 0,
            pageUrlHD: ::std::vec::Vec::new(),
            commentCount: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComicChapterDetail {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComicChapterDetail").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComicChapterDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComicChapterDetail {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ComicChapterInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComicChapterInfo {
    // message fields
    // @@protoc_insertion_point(field:ComicChapterInfo.chapterId)
    pub chapterId: i64,
    // @@protoc_insertion_point(field:ComicChapterInfo.chapterTitle)
    pub chapterTitle: ::std::string::String,
    // @@protoc_insertion_point(field:ComicChapterInfo.updateTime)
    pub updateTime: i64,
    // @@protoc_insertion_point(field:ComicChapterInfo.fileSize)
    pub fileSize: i32,
    // @@protoc_insertion_point(field:ComicChapterInfo.chapterOrder)
    pub chapterOrder: i32,
    // @@protoc_insertion_point(field:ComicChapterInfo.isFee)
    pub isFee: i32,
    // special fields
    // @@protoc_insertion_point(special_field:ComicChapterInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComicChapterInfo {
    fn default() -> &'a ComicChapterInfo {
        <ComicChapterInfo as ::protobuf::Message>::default_instance()
    }
}

impl ComicChapterInfo {
    pub fn new() -> ComicChapterInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chapterId",
            |m: &ComicChapterInfo| { &m.chapterId },
            |m: &mut ComicChapterInfo| { &mut m.chapterId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chapterTitle",
            |m: &ComicChapterInfo| { &m.chapterTitle },
            |m: &mut ComicChapterInfo| { &mut m.chapterTitle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updateTime",
            |m: &ComicChapterInfo| { &m.updateTime },
            |m: &mut ComicChapterInfo| { &mut m.updateTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fileSize",
            |m: &ComicChapterInfo| { &m.fileSize },
            |m: &mut ComicChapterInfo| { &mut m.fileSize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chapterOrder",
            |m: &ComicChapterInfo| { &m.chapterOrder },
            |m: &mut ComicChapterInfo| { &mut m.chapterOrder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isFee",
            |m: &ComicChapterInfo| { &m.isFee },
            |m: &mut ComicChapterInfo| { &mut m.isFee },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComicChapterInfo>(
            "ComicChapterInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComicChapterInfo {
    const NAME: &'static str = "ComicChapterInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chapterId = is.read_int64()?;
                },
                18 => {
                    self.chapterTitle = is.read_string()?;
                },
                24 => {
                    self.updateTime = is.read_int64()?;
                },
                32 => {
                    self.fileSize = is.read_int32()?;
                },
                40 => {
                    self.chapterOrder = is.read_int32()?;
                },
                48 => {
                    self.isFee = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.chapterId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.chapterId);
        }
        if !self.chapterTitle.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.chapterTitle);
        }
        if self.updateTime != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.updateTime);
        }
        if self.fileSize != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.fileSize);
        }
        if self.chapterOrder != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.chapterOrder);
        }
        if self.isFee != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.isFee);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.chapterId != 0 {
            os.write_int64(1, self.chapterId)?;
        }
        if !self.chapterTitle.is_empty() {
            os.write_string(2, &self.chapterTitle)?;
        }
        if self.updateTime != 0 {
            os.write_int64(3, self.updateTime)?;
        }
        if self.fileSize != 0 {
            os.write_int32(4, self.fileSize)?;
        }
        if self.chapterOrder != 0 {
            os.write_int32(5, self.chapterOrder)?;
        }
        if self.isFee != 0 {
            os.write_int32(6, self.isFee)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComicChapterInfo {
        ComicChapterInfo::new()
    }

    fn clear(&mut self) {
        self.chapterId = 0;
        self.chapterTitle.clear();
        self.updateTime = 0;
        self.fileSize = 0;
        self.chapterOrder = 0;
        self.isFee = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComicChapterInfo {
        static instance: ComicChapterInfo = ComicChapterInfo {
            chapterId: 0,
            chapterTitle: ::std::string::String::new(),
            updateTime: 0,
            fileSize: 0,
            chapterOrder: 0,
            isFee: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComicChapterInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComicChapterInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComicChapterInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComicChapterInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ComicChapterResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComicChapterResponse {
    // message fields
    // @@protoc_insertion_point(field:ComicChapterResponse.errno)
    pub errno: i32,
    // @@protoc_insertion_point(field:ComicChapterResponse.errmsg)
    pub errmsg: ::std::string::String,
    // @@protoc_insertion_point(field:ComicChapterResponse.data)
    pub data: ::protobuf::MessageField<ComicChapterDetail>,
    // special fields
    // @@protoc_insertion_point(special_field:ComicChapterResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComicChapterResponse {
    fn default() -> &'a ComicChapterResponse {
        <ComicChapterResponse as ::protobuf::Message>::default_instance()
    }
}

impl ComicChapterResponse {
    pub fn new() -> ComicChapterResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errno",
            |m: &ComicChapterResponse| { &m.errno },
            |m: &mut ComicChapterResponse| { &mut m.errno },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errmsg",
            |m: &ComicChapterResponse| { &m.errmsg },
            |m: &mut ComicChapterResponse| { &mut m.errmsg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ComicChapterDetail>(
            "data",
            |m: &ComicChapterResponse| { &m.data },
            |m: &mut ComicChapterResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComicChapterResponse>(
            "ComicChapterResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComicChapterResponse {
    const NAME: &'static str = "ComicChapterResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.errno = is.read_int32()?;
                },
                18 => {
                    self.errmsg = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.errno != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.errno);
        }
        if !self.errmsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errmsg);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.errno != 0 {
            os.write_int32(1, self.errno)?;
        }
        if !self.errmsg.is_empty() {
            os.write_string(2, &self.errmsg)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComicChapterResponse {
        ComicChapterResponse::new()
    }

    fn clear(&mut self) {
        self.errno = 0;
        self.errmsg.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComicChapterResponse {
        static instance: ComicChapterResponse = ComicChapterResponse {
            errno: 0,
            errmsg: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComicChapterResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComicChapterResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComicChapterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComicChapterResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ComicChapterList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComicChapterList {
    // message fields
    // @@protoc_insertion_point(field:ComicChapterList.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:ComicChapterList.data)
    pub data: ::std::vec::Vec<ComicChapterInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:ComicChapterList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComicChapterList {
    fn default() -> &'a ComicChapterList {
        <ComicChapterList as ::protobuf::Message>::default_instance()
    }
}

impl ComicChapterList {
    pub fn new() -> ComicChapterList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &ComicChapterList| { &m.title },
            |m: &mut ComicChapterList| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &ComicChapterList| { &m.data },
            |m: &mut ComicChapterList| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComicChapterList>(
            "ComicChapterList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComicChapterList {
    const NAME: &'static str = "ComicChapterList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = is.read_string()?;
                },
                18 => {
                    self.data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComicChapterList {
        ComicChapterList::new()
    }

    fn clear(&mut self) {
        self.title.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComicChapterList {
        static instance: ComicChapterList = ComicChapterList {
            title: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComicChapterList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComicChapterList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComicChapterList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComicChapterList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ComicDetailResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComicDetailResponse {
    // message fields
    // @@protoc_insertion_point(field:ComicDetailResponse.errno)
    pub errno: i32,
    // @@protoc_insertion_point(field:ComicDetailResponse.errmsg)
    pub errmsg: ::std::string::String,
    // @@protoc_insertion_point(field:ComicDetailResponse.data)
    pub data: ::protobuf::MessageField<ComicDetail>,
    // special fields
    // @@protoc_insertion_point(special_field:ComicDetailResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComicDetailResponse {
    fn default() -> &'a ComicDetailResponse {
        <ComicDetailResponse as ::protobuf::Message>::default_instance()
    }
}

impl ComicDetailResponse {
    pub fn new() -> ComicDetailResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errno",
            |m: &ComicDetailResponse| { &m.errno },
            |m: &mut ComicDetailResponse| { &mut m.errno },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errmsg",
            |m: &ComicDetailResponse| { &m.errmsg },
            |m: &mut ComicDetailResponse| { &mut m.errmsg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ComicDetail>(
            "data",
            |m: &ComicDetailResponse| { &m.data },
            |m: &mut ComicDetailResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComicDetailResponse>(
            "ComicDetailResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComicDetailResponse {
    const NAME: &'static str = "ComicDetailResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.errno = is.read_int32()?;
                },
                18 => {
                    self.errmsg = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.errno != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.errno);
        }
        if !self.errmsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errmsg);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.errno != 0 {
            os.write_int32(1, self.errno)?;
        }
        if !self.errmsg.is_empty() {
            os.write_string(2, &self.errmsg)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComicDetailResponse {
        ComicDetailResponse::new()
    }

    fn clear(&mut self) {
        self.errno = 0;
        self.errmsg.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComicDetailResponse {
        static instance: ComicDetailResponse = ComicDetailResponse {
            errno: 0,
            errmsg: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComicDetailResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComicDetailResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComicDetailResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComicDetailResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ComicDetail)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComicDetail {
    // message fields
    // @@protoc_insertion_point(field:ComicDetail.id)
    pub id: i64,
    // @@protoc_insertion_point(field:ComicDetail.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:ComicDetail.direction)
    pub direction: i32,
    // @@protoc_insertion_point(field:ComicDetail.islong)
    pub islong: i32,
    // @@protoc_insertion_point(field:ComicDetail.isDmzj)
    pub isDmzj: i32,
    // @@protoc_insertion_point(field:ComicDetail.cover)
    pub cover: ::std::string::String,
    // @@protoc_insertion_point(field:ComicDetail.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:ComicDetail.lastUpdatetime)
    pub lastUpdatetime: i64,
    // @@protoc_insertion_point(field:ComicDetail.lastUpdateChapterName)
    pub lastUpdateChapterName: ::std::string::String,
    // @@protoc_insertion_point(field:ComicDetail.copyright)
    pub copyright: i32,
    // @@protoc_insertion_point(field:ComicDetail.firstLetter)
    pub firstLetter: ::std::string::String,
    // @@protoc_insertion_point(field:ComicDetail.comicPy)
    pub comicPy: ::std::string::String,
    // @@protoc_insertion_point(field:ComicDetail.hidden)
    pub hidden: i32,
    // @@protoc_insertion_point(field:ComicDetail.hotNum)
    pub hotNum: i64,
    // @@protoc_insertion_point(field:ComicDetail.hitNum)
    pub hitNum: i64,
    // @@protoc_insertion_point(field:ComicDetail.uid)
    pub uid: i64,
    // @@protoc_insertion_point(field:ComicDetail.isLock)
    pub isLock: i32,
    // @@protoc_insertion_point(field:ComicDetail.lastUpdateChapterId)
    pub lastUpdateChapterId: i32,
    // @@protoc_insertion_point(field:ComicDetail.types)
    pub types: ::std::vec::Vec<ComicTag>,
    // @@protoc_insertion_point(field:ComicDetail.status)
    pub status: ::std::vec::Vec<ComicTag>,
    // @@protoc_insertion_point(field:ComicDetail.authors)
    pub authors: ::std::vec::Vec<ComicTag>,
    // @@protoc_insertion_point(field:ComicDetail.subscribeNum)
    pub subscribeNum: i64,
    // @@protoc_insertion_point(field:ComicDetail.chapters)
    pub chapters: ::std::vec::Vec<ComicChapterList>,
    // @@protoc_insertion_point(field:ComicDetail.isNeedLogin)
    pub isNeedLogin: i32,
    // @@protoc_insertion_point(field:ComicDetail.urlLinks)
    pub urlLinks: ::std::vec::Vec<ComicDetailUrlLink>,
    // @@protoc_insertion_point(field:ComicDetail.isHideChapter)
    pub isHideChapter: i32,
    // @@protoc_insertion_point(field:ComicDetail.dhUrlLinks)
    pub dhUrlLinks: ::std::vec::Vec<ComicDetailUrlLink>,
    // @@protoc_insertion_point(field:ComicDetail.cornerMark)
    pub cornerMark: ::std::string::String,
    // @@protoc_insertion_point(field:ComicDetail.isFee)
    pub isFee: i32,
    // special fields
    // @@protoc_insertion_point(special_field:ComicDetail.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComicDetail {
    fn default() -> &'a ComicDetail {
        <ComicDetail as ::protobuf::Message>::default_instance()
    }
}

impl ComicDetail {
    pub fn new() -> ComicDetail {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(29);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ComicDetail| { &m.id },
            |m: &mut ComicDetail| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &ComicDetail| { &m.title },
            |m: &mut ComicDetail| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &ComicDetail| { &m.direction },
            |m: &mut ComicDetail| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "islong",
            |m: &ComicDetail| { &m.islong },
            |m: &mut ComicDetail| { &mut m.islong },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isDmzj",
            |m: &ComicDetail| { &m.isDmzj },
            |m: &mut ComicDetail| { &mut m.isDmzj },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cover",
            |m: &ComicDetail| { &m.cover },
            |m: &mut ComicDetail| { &mut m.cover },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &ComicDetail| { &m.description },
            |m: &mut ComicDetail| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lastUpdatetime",
            |m: &ComicDetail| { &m.lastUpdatetime },
            |m: &mut ComicDetail| { &mut m.lastUpdatetime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lastUpdateChapterName",
            |m: &ComicDetail| { &m.lastUpdateChapterName },
            |m: &mut ComicDetail| { &mut m.lastUpdateChapterName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "copyright",
            |m: &ComicDetail| { &m.copyright },
            |m: &mut ComicDetail| { &mut m.copyright },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "firstLetter",
            |m: &ComicDetail| { &m.firstLetter },
            |m: &mut ComicDetail| { &mut m.firstLetter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comicPy",
            |m: &ComicDetail| { &m.comicPy },
            |m: &mut ComicDetail| { &mut m.comicPy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hidden",
            |m: &ComicDetail| { &m.hidden },
            |m: &mut ComicDetail| { &mut m.hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hotNum",
            |m: &ComicDetail| { &m.hotNum },
            |m: &mut ComicDetail| { &mut m.hotNum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hitNum",
            |m: &ComicDetail| { &m.hitNum },
            |m: &mut ComicDetail| { &mut m.hitNum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uid",
            |m: &ComicDetail| { &m.uid },
            |m: &mut ComicDetail| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isLock",
            |m: &ComicDetail| { &m.isLock },
            |m: &mut ComicDetail| { &mut m.isLock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lastUpdateChapterId",
            |m: &ComicDetail| { &m.lastUpdateChapterId },
            |m: &mut ComicDetail| { &mut m.lastUpdateChapterId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "types",
            |m: &ComicDetail| { &m.types },
            |m: &mut ComicDetail| { &mut m.types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "status",
            |m: &ComicDetail| { &m.status },
            |m: &mut ComicDetail| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "authors",
            |m: &ComicDetail| { &m.authors },
            |m: &mut ComicDetail| { &mut m.authors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscribeNum",
            |m: &ComicDetail| { &m.subscribeNum },
            |m: &mut ComicDetail| { &mut m.subscribeNum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chapters",
            |m: &ComicDetail| { &m.chapters },
            |m: &mut ComicDetail| { &mut m.chapters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isNeedLogin",
            |m: &ComicDetail| { &m.isNeedLogin },
            |m: &mut ComicDetail| { &mut m.isNeedLogin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "urlLinks",
            |m: &ComicDetail| { &m.urlLinks },
            |m: &mut ComicDetail| { &mut m.urlLinks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isHideChapter",
            |m: &ComicDetail| { &m.isHideChapter },
            |m: &mut ComicDetail| { &mut m.isHideChapter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dhUrlLinks",
            |m: &ComicDetail| { &m.dhUrlLinks },
            |m: &mut ComicDetail| { &mut m.dhUrlLinks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cornerMark",
            |m: &ComicDetail| { &m.cornerMark },
            |m: &mut ComicDetail| { &mut m.cornerMark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isFee",
            |m: &ComicDetail| { &m.isFee },
            |m: &mut ComicDetail| { &mut m.isFee },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComicDetail>(
            "ComicDetail",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComicDetail {
    const NAME: &'static str = "ComicDetail";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int64()?;
                },
                18 => {
                    self.title = is.read_string()?;
                },
                24 => {
                    self.direction = is.read_int32()?;
                },
                32 => {
                    self.islong = is.read_int32()?;
                },
                40 => {
                    self.isDmzj = is.read_int32()?;
                },
                50 => {
                    self.cover = is.read_string()?;
                },
                58 => {
                    self.description = is.read_string()?;
                },
                64 => {
                    self.lastUpdatetime = is.read_int64()?;
                },
                74 => {
                    self.lastUpdateChapterName = is.read_string()?;
                },
                80 => {
                    self.copyright = is.read_int32()?;
                },
                90 => {
                    self.firstLetter = is.read_string()?;
                },
                98 => {
                    self.comicPy = is.read_string()?;
                },
                104 => {
                    self.hidden = is.read_int32()?;
                },
                112 => {
                    self.hotNum = is.read_int64()?;
                },
                120 => {
                    self.hitNum = is.read_int64()?;
                },
                128 => {
                    self.uid = is.read_int64()?;
                },
                136 => {
                    self.isLock = is.read_int32()?;
                },
                144 => {
                    self.lastUpdateChapterId = is.read_int32()?;
                },
                154 => {
                    self.types.push(is.read_message()?);
                },
                162 => {
                    self.status.push(is.read_message()?);
                },
                170 => {
                    self.authors.push(is.read_message()?);
                },
                176 => {
                    self.subscribeNum = is.read_int64()?;
                },
                186 => {
                    self.chapters.push(is.read_message()?);
                },
                192 => {
                    self.isNeedLogin = is.read_int32()?;
                },
                202 => {
                    self.urlLinks.push(is.read_message()?);
                },
                208 => {
                    self.isHideChapter = is.read_int32()?;
                },
                218 => {
                    self.dhUrlLinks.push(is.read_message()?);
                },
                226 => {
                    self.cornerMark = is.read_string()?;
                },
                232 => {
                    self.isFee = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.id);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        if self.direction != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.direction);
        }
        if self.islong != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.islong);
        }
        if self.isDmzj != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.isDmzj);
        }
        if !self.cover.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.cover);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.description);
        }
        if self.lastUpdatetime != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.lastUpdatetime);
        }
        if !self.lastUpdateChapterName.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.lastUpdateChapterName);
        }
        if self.copyright != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.copyright);
        }
        if !self.firstLetter.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.firstLetter);
        }
        if !self.comicPy.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.comicPy);
        }
        if self.hidden != 0 {
            my_size += ::protobuf::rt::int32_size(13, self.hidden);
        }
        if self.hotNum != 0 {
            my_size += ::protobuf::rt::int64_size(14, self.hotNum);
        }
        if self.hitNum != 0 {
            my_size += ::protobuf::rt::int64_size(15, self.hitNum);
        }
        if self.uid != 0 {
            my_size += ::protobuf::rt::int64_size(16, self.uid);
        }
        if self.isLock != 0 {
            my_size += ::protobuf::rt::int32_size(17, self.isLock);
        }
        if self.lastUpdateChapterId != 0 {
            my_size += ::protobuf::rt::int32_size(18, self.lastUpdateChapterId);
        }
        for value in &self.types {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.status {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.authors {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.subscribeNum != 0 {
            my_size += ::protobuf::rt::int64_size(22, self.subscribeNum);
        }
        for value in &self.chapters {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.isNeedLogin != 0 {
            my_size += ::protobuf::rt::int32_size(24, self.isNeedLogin);
        }
        for value in &self.urlLinks {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.isHideChapter != 0 {
            my_size += ::protobuf::rt::int32_size(26, self.isHideChapter);
        }
        for value in &self.dhUrlLinks {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.cornerMark.is_empty() {
            my_size += ::protobuf::rt::string_size(28, &self.cornerMark);
        }
        if self.isFee != 0 {
            my_size += ::protobuf::rt::int32_size(29, self.isFee);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        if self.direction != 0 {
            os.write_int32(3, self.direction)?;
        }
        if self.islong != 0 {
            os.write_int32(4, self.islong)?;
        }
        if self.isDmzj != 0 {
            os.write_int32(5, self.isDmzj)?;
        }
        if !self.cover.is_empty() {
            os.write_string(6, &self.cover)?;
        }
        if !self.description.is_empty() {
            os.write_string(7, &self.description)?;
        }
        if self.lastUpdatetime != 0 {
            os.write_int64(8, self.lastUpdatetime)?;
        }
        if !self.lastUpdateChapterName.is_empty() {
            os.write_string(9, &self.lastUpdateChapterName)?;
        }
        if self.copyright != 0 {
            os.write_int32(10, self.copyright)?;
        }
        if !self.firstLetter.is_empty() {
            os.write_string(11, &self.firstLetter)?;
        }
        if !self.comicPy.is_empty() {
            os.write_string(12, &self.comicPy)?;
        }
        if self.hidden != 0 {
            os.write_int32(13, self.hidden)?;
        }
        if self.hotNum != 0 {
            os.write_int64(14, self.hotNum)?;
        }
        if self.hitNum != 0 {
            os.write_int64(15, self.hitNum)?;
        }
        if self.uid != 0 {
            os.write_int64(16, self.uid)?;
        }
        if self.isLock != 0 {
            os.write_int32(17, self.isLock)?;
        }
        if self.lastUpdateChapterId != 0 {
            os.write_int32(18, self.lastUpdateChapterId)?;
        }
        for v in &self.types {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        for v in &self.status {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        for v in &self.authors {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        };
        if self.subscribeNum != 0 {
            os.write_int64(22, self.subscribeNum)?;
        }
        for v in &self.chapters {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        };
        if self.isNeedLogin != 0 {
            os.write_int32(24, self.isNeedLogin)?;
        }
        for v in &self.urlLinks {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        if self.isHideChapter != 0 {
            os.write_int32(26, self.isHideChapter)?;
        }
        for v in &self.dhUrlLinks {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        };
        if !self.cornerMark.is_empty() {
            os.write_string(28, &self.cornerMark)?;
        }
        if self.isFee != 0 {
            os.write_int32(29, self.isFee)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComicDetail {
        ComicDetail::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.title.clear();
        self.direction = 0;
        self.islong = 0;
        self.isDmzj = 0;
        self.cover.clear();
        self.description.clear();
        self.lastUpdatetime = 0;
        self.lastUpdateChapterName.clear();
        self.copyright = 0;
        self.firstLetter.clear();
        self.comicPy.clear();
        self.hidden = 0;
        self.hotNum = 0;
        self.hitNum = 0;
        self.uid = 0;
        self.isLock = 0;
        self.lastUpdateChapterId = 0;
        self.types.clear();
        self.status.clear();
        self.authors.clear();
        self.subscribeNum = 0;
        self.chapters.clear();
        self.isNeedLogin = 0;
        self.urlLinks.clear();
        self.isHideChapter = 0;
        self.dhUrlLinks.clear();
        self.cornerMark.clear();
        self.isFee = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComicDetail {
        static instance: ComicDetail = ComicDetail {
            id: 0,
            title: ::std::string::String::new(),
            direction: 0,
            islong: 0,
            isDmzj: 0,
            cover: ::std::string::String::new(),
            description: ::std::string::String::new(),
            lastUpdatetime: 0,
            lastUpdateChapterName: ::std::string::String::new(),
            copyright: 0,
            firstLetter: ::std::string::String::new(),
            comicPy: ::std::string::String::new(),
            hidden: 0,
            hotNum: 0,
            hitNum: 0,
            uid: 0,
            isLock: 0,
            lastUpdateChapterId: 0,
            types: ::std::vec::Vec::new(),
            status: ::std::vec::Vec::new(),
            authors: ::std::vec::Vec::new(),
            subscribeNum: 0,
            chapters: ::std::vec::Vec::new(),
            isNeedLogin: 0,
            urlLinks: ::std::vec::Vec::new(),
            isHideChapter: 0,
            dhUrlLinks: ::std::vec::Vec::new(),
            cornerMark: ::std::string::String::new(),
            isFee: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComicDetail {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComicDetail").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComicDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComicDetail {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ComicTag)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComicTag {
    // message fields
    // @@protoc_insertion_point(field:ComicTag.tagId)
    pub tagId: i64,
    // @@protoc_insertion_point(field:ComicTag.tagName)
    pub tagName: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ComicTag.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComicTag {
    fn default() -> &'a ComicTag {
        <ComicTag as ::protobuf::Message>::default_instance()
    }
}

impl ComicTag {
    pub fn new() -> ComicTag {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tagId",
            |m: &ComicTag| { &m.tagId },
            |m: &mut ComicTag| { &mut m.tagId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tagName",
            |m: &ComicTag| { &m.tagName },
            |m: &mut ComicTag| { &mut m.tagName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComicTag>(
            "ComicTag",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComicTag {
    const NAME: &'static str = "ComicTag";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tagId = is.read_int64()?;
                },
                18 => {
                    self.tagName = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.tagId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.tagId);
        }
        if !self.tagName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tagName);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.tagId != 0 {
            os.write_int64(1, self.tagId)?;
        }
        if !self.tagName.is_empty() {
            os.write_string(2, &self.tagName)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComicTag {
        ComicTag::new()
    }

    fn clear(&mut self) {
        self.tagId = 0;
        self.tagName.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComicTag {
        static instance: ComicTag = ComicTag {
            tagId: 0,
            tagName: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComicTag {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComicTag").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComicTag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComicTag {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ComicDetailUrlLink)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComicDetailUrlLink {
    // message fields
    // @@protoc_insertion_point(field:ComicDetailUrlLink.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:ComicDetailUrlLink.list)
    pub list: ::std::vec::Vec<ComicDetailUrl>,
    // special fields
    // @@protoc_insertion_point(special_field:ComicDetailUrlLink.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComicDetailUrlLink {
    fn default() -> &'a ComicDetailUrlLink {
        <ComicDetailUrlLink as ::protobuf::Message>::default_instance()
    }
}

impl ComicDetailUrlLink {
    pub fn new() -> ComicDetailUrlLink {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &ComicDetailUrlLink| { &m.title },
            |m: &mut ComicDetailUrlLink| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "list",
            |m: &ComicDetailUrlLink| { &m.list },
            |m: &mut ComicDetailUrlLink| { &mut m.list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComicDetailUrlLink>(
            "ComicDetailUrlLink",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComicDetailUrlLink {
    const NAME: &'static str = "ComicDetailUrlLink";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = is.read_string()?;
                },
                18 => {
                    self.list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        for value in &self.list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        for v in &self.list {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComicDetailUrlLink {
        ComicDetailUrlLink::new()
    }

    fn clear(&mut self) {
        self.title.clear();
        self.list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComicDetailUrlLink {
        static instance: ComicDetailUrlLink = ComicDetailUrlLink {
            title: ::std::string::String::new(),
            list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComicDetailUrlLink {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComicDetailUrlLink").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComicDetailUrlLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComicDetailUrlLink {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ComicDetailUrl)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComicDetailUrl {
    // message fields
    // @@protoc_insertion_point(field:ComicDetailUrl.id)
    pub id: i64,
    // @@protoc_insertion_point(field:ComicDetailUrl.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:ComicDetailUrl.url)
    pub url: ::std::string::String,
    // @@protoc_insertion_point(field:ComicDetailUrl.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ComicDetailUrl.packageName)
    pub packageName: ::std::string::String,
    // @@protoc_insertion_point(field:ComicDetailUrl.dUrl)
    pub dUrl: ::std::string::String,
    // @@protoc_insertion_point(field:ComicDetailUrl.btype)
    pub btype: i32,
    // special fields
    // @@protoc_insertion_point(special_field:ComicDetailUrl.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComicDetailUrl {
    fn default() -> &'a ComicDetailUrl {
        <ComicDetailUrl as ::protobuf::Message>::default_instance()
    }
}

impl ComicDetailUrl {
    pub fn new() -> ComicDetailUrl {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ComicDetailUrl| { &m.id },
            |m: &mut ComicDetailUrl| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &ComicDetailUrl| { &m.title },
            |m: &mut ComicDetailUrl| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &ComicDetailUrl| { &m.url },
            |m: &mut ComicDetailUrl| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ComicDetailUrl| { &m.icon },
            |m: &mut ComicDetailUrl| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "packageName",
            |m: &ComicDetailUrl| { &m.packageName },
            |m: &mut ComicDetailUrl| { &mut m.packageName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dUrl",
            |m: &ComicDetailUrl| { &m.dUrl },
            |m: &mut ComicDetailUrl| { &mut m.dUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "btype",
            |m: &ComicDetailUrl| { &m.btype },
            |m: &mut ComicDetailUrl| { &mut m.btype },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComicDetailUrl>(
            "ComicDetailUrl",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComicDetailUrl {
    const NAME: &'static str = "ComicDetailUrl";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int64()?;
                },
                18 => {
                    self.title = is.read_string()?;
                },
                26 => {
                    self.url = is.read_string()?;
                },
                34 => {
                    self.icon = is.read_string()?;
                },
                42 => {
                    self.packageName = is.read_string()?;
                },
                50 => {
                    self.dUrl = is.read_string()?;
                },
                56 => {
                    self.btype = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.id);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.url);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.icon);
        }
        if !self.packageName.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.packageName);
        }
        if !self.dUrl.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.dUrl);
        }
        if self.btype != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.btype);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        if !self.url.is_empty() {
            os.write_string(3, &self.url)?;
        }
        if !self.icon.is_empty() {
            os.write_string(4, &self.icon)?;
        }
        if !self.packageName.is_empty() {
            os.write_string(5, &self.packageName)?;
        }
        if !self.dUrl.is_empty() {
            os.write_string(6, &self.dUrl)?;
        }
        if self.btype != 0 {
            os.write_int32(7, self.btype)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComicDetailUrl {
        ComicDetailUrl::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.title.clear();
        self.url.clear();
        self.icon.clear();
        self.packageName.clear();
        self.dUrl.clear();
        self.btype = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComicDetailUrl {
        static instance: ComicDetailUrl = ComicDetailUrl {
            id: 0,
            title: ::std::string::String::new(),
            url: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            packageName: ::std::string::String::new(),
            dUrl: ::std::string::String::new(),
            btype: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComicDetailUrl {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComicDetailUrl").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComicDetailUrl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComicDetailUrl {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ComicRankListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComicRankListResponse {
    // message fields
    // @@protoc_insertion_point(field:ComicRankListResponse.errno)
    pub errno: i32,
    // @@protoc_insertion_point(field:ComicRankListResponse.errmsg)
    pub errmsg: ::std::string::String,
    // @@protoc_insertion_point(field:ComicRankListResponse.data)
    pub data: ::std::vec::Vec<ComicRankListInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:ComicRankListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComicRankListResponse {
    fn default() -> &'a ComicRankListResponse {
        <ComicRankListResponse as ::protobuf::Message>::default_instance()
    }
}

impl ComicRankListResponse {
    pub fn new() -> ComicRankListResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errno",
            |m: &ComicRankListResponse| { &m.errno },
            |m: &mut ComicRankListResponse| { &mut m.errno },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errmsg",
            |m: &ComicRankListResponse| { &m.errmsg },
            |m: &mut ComicRankListResponse| { &mut m.errmsg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &ComicRankListResponse| { &m.data },
            |m: &mut ComicRankListResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComicRankListResponse>(
            "ComicRankListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComicRankListResponse {
    const NAME: &'static str = "ComicRankListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.errno = is.read_int32()?;
                },
                18 => {
                    self.errmsg = is.read_string()?;
                },
                26 => {
                    self.data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.errno != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.errno);
        }
        if !self.errmsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errmsg);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.errno != 0 {
            os.write_int32(1, self.errno)?;
        }
        if !self.errmsg.is_empty() {
            os.write_string(2, &self.errmsg)?;
        }
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComicRankListResponse {
        ComicRankListResponse::new()
    }

    fn clear(&mut self) {
        self.errno = 0;
        self.errmsg.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComicRankListResponse {
        static instance: ComicRankListResponse = ComicRankListResponse {
            errno: 0,
            errmsg: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComicRankListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComicRankListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComicRankListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComicRankListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ComicRankListInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComicRankListInfo {
    // message fields
    // @@protoc_insertion_point(field:ComicRankListInfo.comic_id)
    pub comic_id: i64,
    // @@protoc_insertion_point(field:ComicRankListInfo.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:ComicRankListInfo.authors)
    pub authors: ::std::string::String,
    // @@protoc_insertion_point(field:ComicRankListInfo.status)
    pub status: ::std::string::String,
    // @@protoc_insertion_point(field:ComicRankListInfo.cover)
    pub cover: ::std::string::String,
    // @@protoc_insertion_point(field:ComicRankListInfo.types)
    pub types: ::std::string::String,
    // @@protoc_insertion_point(field:ComicRankListInfo.last_updatetime)
    pub last_updatetime: i64,
    // @@protoc_insertion_point(field:ComicRankListInfo.last_update_chapter_name)
    pub last_update_chapter_name: ::std::string::String,
    // @@protoc_insertion_point(field:ComicRankListInfo.comic_py)
    pub comic_py: ::std::string::String,
    // @@protoc_insertion_point(field:ComicRankListInfo.num)
    pub num: i64,
    // @@protoc_insertion_point(field:ComicRankListInfo.tag_id)
    pub tag_id: i32,
    // @@protoc_insertion_point(field:ComicRankListInfo.chapter_name)
    pub chapter_name: ::std::string::String,
    // @@protoc_insertion_point(field:ComicRankListInfo.chapter_id)
    pub chapter_id: i64,
    // special fields
    // @@protoc_insertion_point(special_field:ComicRankListInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComicRankListInfo {
    fn default() -> &'a ComicRankListInfo {
        <ComicRankListInfo as ::protobuf::Message>::default_instance()
    }
}

impl ComicRankListInfo {
    pub fn new() -> ComicRankListInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comic_id",
            |m: &ComicRankListInfo| { &m.comic_id },
            |m: &mut ComicRankListInfo| { &mut m.comic_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &ComicRankListInfo| { &m.title },
            |m: &mut ComicRankListInfo| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "authors",
            |m: &ComicRankListInfo| { &m.authors },
            |m: &mut ComicRankListInfo| { &mut m.authors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &ComicRankListInfo| { &m.status },
            |m: &mut ComicRankListInfo| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cover",
            |m: &ComicRankListInfo| { &m.cover },
            |m: &mut ComicRankListInfo| { &mut m.cover },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "types",
            |m: &ComicRankListInfo| { &m.types },
            |m: &mut ComicRankListInfo| { &mut m.types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_updatetime",
            |m: &ComicRankListInfo| { &m.last_updatetime },
            |m: &mut ComicRankListInfo| { &mut m.last_updatetime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_update_chapter_name",
            |m: &ComicRankListInfo| { &m.last_update_chapter_name },
            |m: &mut ComicRankListInfo| { &mut m.last_update_chapter_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comic_py",
            |m: &ComicRankListInfo| { &m.comic_py },
            |m: &mut ComicRankListInfo| { &mut m.comic_py },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num",
            |m: &ComicRankListInfo| { &m.num },
            |m: &mut ComicRankListInfo| { &mut m.num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tag_id",
            |m: &ComicRankListInfo| { &m.tag_id },
            |m: &mut ComicRankListInfo| { &mut m.tag_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chapter_name",
            |m: &ComicRankListInfo| { &m.chapter_name },
            |m: &mut ComicRankListInfo| { &mut m.chapter_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chapter_id",
            |m: &ComicRankListInfo| { &m.chapter_id },
            |m: &mut ComicRankListInfo| { &mut m.chapter_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComicRankListInfo>(
            "ComicRankListInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComicRankListInfo {
    const NAME: &'static str = "ComicRankListInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.comic_id = is.read_int64()?;
                },
                18 => {
                    self.title = is.read_string()?;
                },
                26 => {
                    self.authors = is.read_string()?;
                },
                34 => {
                    self.status = is.read_string()?;
                },
                42 => {
                    self.cover = is.read_string()?;
                },
                50 => {
                    self.types = is.read_string()?;
                },
                56 => {
                    self.last_updatetime = is.read_int64()?;
                },
                66 => {
                    self.last_update_chapter_name = is.read_string()?;
                },
                74 => {
                    self.comic_py = is.read_string()?;
                },
                80 => {
                    self.num = is.read_int64()?;
                },
                88 => {
                    self.tag_id = is.read_int32()?;
                },
                98 => {
                    self.chapter_name = is.read_string()?;
                },
                104 => {
                    self.chapter_id = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.comic_id != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.comic_id);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        if !self.authors.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.authors);
        }
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.status);
        }
        if !self.cover.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.cover);
        }
        if !self.types.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.types);
        }
        if self.last_updatetime != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.last_updatetime);
        }
        if !self.last_update_chapter_name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.last_update_chapter_name);
        }
        if !self.comic_py.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.comic_py);
        }
        if self.num != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.num);
        }
        if self.tag_id != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.tag_id);
        }
        if !self.chapter_name.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.chapter_name);
        }
        if self.chapter_id != 0 {
            my_size += ::protobuf::rt::int64_size(13, self.chapter_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.comic_id != 0 {
            os.write_int64(1, self.comic_id)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        if !self.authors.is_empty() {
            os.write_string(3, &self.authors)?;
        }
        if !self.status.is_empty() {
            os.write_string(4, &self.status)?;
        }
        if !self.cover.is_empty() {
            os.write_string(5, &self.cover)?;
        }
        if !self.types.is_empty() {
            os.write_string(6, &self.types)?;
        }
        if self.last_updatetime != 0 {
            os.write_int64(7, self.last_updatetime)?;
        }
        if !self.last_update_chapter_name.is_empty() {
            os.write_string(8, &self.last_update_chapter_name)?;
        }
        if !self.comic_py.is_empty() {
            os.write_string(9, &self.comic_py)?;
        }
        if self.num != 0 {
            os.write_int64(10, self.num)?;
        }
        if self.tag_id != 0 {
            os.write_int32(11, self.tag_id)?;
        }
        if !self.chapter_name.is_empty() {
            os.write_string(12, &self.chapter_name)?;
        }
        if self.chapter_id != 0 {
            os.write_int64(13, self.chapter_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComicRankListInfo {
        ComicRankListInfo::new()
    }

    fn clear(&mut self) {
        self.comic_id = 0;
        self.title.clear();
        self.authors.clear();
        self.status.clear();
        self.cover.clear();
        self.types.clear();
        self.last_updatetime = 0;
        self.last_update_chapter_name.clear();
        self.comic_py.clear();
        self.num = 0;
        self.tag_id = 0;
        self.chapter_name.clear();
        self.chapter_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComicRankListInfo {
        static instance: ComicRankListInfo = ComicRankListInfo {
            comic_id: 0,
            title: ::std::string::String::new(),
            authors: ::std::string::String::new(),
            status: ::std::string::String::new(),
            cover: ::std::string::String::new(),
            types: ::std::string::String::new(),
            last_updatetime: 0,
            last_update_chapter_name: ::std::string::String::new(),
            comic_py: ::std::string::String::new(),
            num: 0,
            tag_id: 0,
            chapter_name: ::std::string::String::new(),
            chapter_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComicRankListInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComicRankListInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComicRankListInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComicRankListInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:RankTypeFilterResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RankTypeFilterResponse {
    // message fields
    // @@protoc_insertion_point(field:RankTypeFilterResponse.errno)
    pub errno: i32,
    // @@protoc_insertion_point(field:RankTypeFilterResponse.errmsg)
    pub errmsg: ::std::string::String,
    // @@protoc_insertion_point(field:RankTypeFilterResponse.data)
    pub data: ::std::vec::Vec<ComicTag>,
    // special fields
    // @@protoc_insertion_point(special_field:RankTypeFilterResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RankTypeFilterResponse {
    fn default() -> &'a RankTypeFilterResponse {
        <RankTypeFilterResponse as ::protobuf::Message>::default_instance()
    }
}

impl RankTypeFilterResponse {
    pub fn new() -> RankTypeFilterResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errno",
            |m: &RankTypeFilterResponse| { &m.errno },
            |m: &mut RankTypeFilterResponse| { &mut m.errno },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errmsg",
            |m: &RankTypeFilterResponse| { &m.errmsg },
            |m: &mut RankTypeFilterResponse| { &mut m.errmsg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &RankTypeFilterResponse| { &m.data },
            |m: &mut RankTypeFilterResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RankTypeFilterResponse>(
            "RankTypeFilterResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RankTypeFilterResponse {
    const NAME: &'static str = "RankTypeFilterResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.errno = is.read_int32()?;
                },
                18 => {
                    self.errmsg = is.read_string()?;
                },
                26 => {
                    self.data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.errno != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.errno);
        }
        if !self.errmsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errmsg);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.errno != 0 {
            os.write_int32(1, self.errno)?;
        }
        if !self.errmsg.is_empty() {
            os.write_string(2, &self.errmsg)?;
        }
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RankTypeFilterResponse {
        RankTypeFilterResponse::new()
    }

    fn clear(&mut self) {
        self.errno = 0;
        self.errmsg.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RankTypeFilterResponse {
        static instance: RankTypeFilterResponse = RankTypeFilterResponse {
            errno: 0,
            errmsg: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RankTypeFilterResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RankTypeFilterResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RankTypeFilterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RankTypeFilterResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ComicUpdateListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComicUpdateListResponse {
    // message fields
    // @@protoc_insertion_point(field:ComicUpdateListResponse.errno)
    pub errno: i32,
    // @@protoc_insertion_point(field:ComicUpdateListResponse.errmsg)
    pub errmsg: ::std::string::String,
    // @@protoc_insertion_point(field:ComicUpdateListResponse.data)
    pub data: ::std::vec::Vec<ComicUpdateListInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:ComicUpdateListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComicUpdateListResponse {
    fn default() -> &'a ComicUpdateListResponse {
        <ComicUpdateListResponse as ::protobuf::Message>::default_instance()
    }
}

impl ComicUpdateListResponse {
    pub fn new() -> ComicUpdateListResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errno",
            |m: &ComicUpdateListResponse| { &m.errno },
            |m: &mut ComicUpdateListResponse| { &mut m.errno },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errmsg",
            |m: &ComicUpdateListResponse| { &m.errmsg },
            |m: &mut ComicUpdateListResponse| { &mut m.errmsg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &ComicUpdateListResponse| { &m.data },
            |m: &mut ComicUpdateListResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComicUpdateListResponse>(
            "ComicUpdateListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComicUpdateListResponse {
    const NAME: &'static str = "ComicUpdateListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.errno = is.read_int32()?;
                },
                18 => {
                    self.errmsg = is.read_string()?;
                },
                26 => {
                    self.data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.errno != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.errno);
        }
        if !self.errmsg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.errmsg);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.errno != 0 {
            os.write_int32(1, self.errno)?;
        }
        if !self.errmsg.is_empty() {
            os.write_string(2, &self.errmsg)?;
        }
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComicUpdateListResponse {
        ComicUpdateListResponse::new()
    }

    fn clear(&mut self) {
        self.errno = 0;
        self.errmsg.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComicUpdateListResponse {
        static instance: ComicUpdateListResponse = ComicUpdateListResponse {
            errno: 0,
            errmsg: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComicUpdateListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComicUpdateListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComicUpdateListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComicUpdateListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ComicUpdateListInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComicUpdateListInfo {
    // message fields
    // @@protoc_insertion_point(field:ComicUpdateListInfo.comicId)
    pub comicId: i64,
    // @@protoc_insertion_point(field:ComicUpdateListInfo.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:ComicUpdateListInfo.islong)
    pub islong: i32,
    // @@protoc_insertion_point(field:ComicUpdateListInfo.authors)
    pub authors: ::std::string::String,
    // @@protoc_insertion_point(field:ComicUpdateListInfo.types)
    pub types: ::std::string::String,
    // @@protoc_insertion_point(field:ComicUpdateListInfo.cover)
    pub cover: ::std::string::String,
    // @@protoc_insertion_point(field:ComicUpdateListInfo.status)
    pub status: ::std::string::String,
    // @@protoc_insertion_point(field:ComicUpdateListInfo.lastUpdateChapterName)
    pub lastUpdateChapterName: ::std::string::String,
    // @@protoc_insertion_point(field:ComicUpdateListInfo.lastUpdateChapterId)
    pub lastUpdateChapterId: i64,
    // @@protoc_insertion_point(field:ComicUpdateListInfo.lastUpdatetime)
    pub lastUpdatetime: i64,
    // special fields
    // @@protoc_insertion_point(special_field:ComicUpdateListInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComicUpdateListInfo {
    fn default() -> &'a ComicUpdateListInfo {
        <ComicUpdateListInfo as ::protobuf::Message>::default_instance()
    }
}

impl ComicUpdateListInfo {
    pub fn new() -> ComicUpdateListInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comicId",
            |m: &ComicUpdateListInfo| { &m.comicId },
            |m: &mut ComicUpdateListInfo| { &mut m.comicId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &ComicUpdateListInfo| { &m.title },
            |m: &mut ComicUpdateListInfo| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "islong",
            |m: &ComicUpdateListInfo| { &m.islong },
            |m: &mut ComicUpdateListInfo| { &mut m.islong },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "authors",
            |m: &ComicUpdateListInfo| { &m.authors },
            |m: &mut ComicUpdateListInfo| { &mut m.authors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "types",
            |m: &ComicUpdateListInfo| { &m.types },
            |m: &mut ComicUpdateListInfo| { &mut m.types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cover",
            |m: &ComicUpdateListInfo| { &m.cover },
            |m: &mut ComicUpdateListInfo| { &mut m.cover },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &ComicUpdateListInfo| { &m.status },
            |m: &mut ComicUpdateListInfo| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lastUpdateChapterName",
            |m: &ComicUpdateListInfo| { &m.lastUpdateChapterName },
            |m: &mut ComicUpdateListInfo| { &mut m.lastUpdateChapterName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lastUpdateChapterId",
            |m: &ComicUpdateListInfo| { &m.lastUpdateChapterId },
            |m: &mut ComicUpdateListInfo| { &mut m.lastUpdateChapterId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lastUpdatetime",
            |m: &ComicUpdateListInfo| { &m.lastUpdatetime },
            |m: &mut ComicUpdateListInfo| { &mut m.lastUpdatetime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComicUpdateListInfo>(
            "ComicUpdateListInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ComicUpdateListInfo {
    const NAME: &'static str = "ComicUpdateListInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.comicId = is.read_int64()?;
                },
                18 => {
                    self.title = is.read_string()?;
                },
                24 => {
                    self.islong = is.read_int32()?;
                },
                34 => {
                    self.authors = is.read_string()?;
                },
                42 => {
                    self.types = is.read_string()?;
                },
                50 => {
                    self.cover = is.read_string()?;
                },
                58 => {
                    self.status = is.read_string()?;
                },
                66 => {
                    self.lastUpdateChapterName = is.read_string()?;
                },
                72 => {
                    self.lastUpdateChapterId = is.read_int64()?;
                },
                80 => {
                    self.lastUpdatetime = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.comicId != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.comicId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        if self.islong != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.islong);
        }
        if !self.authors.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.authors);
        }
        if !self.types.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.types);
        }
        if !self.cover.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.cover);
        }
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.status);
        }
        if !self.lastUpdateChapterName.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.lastUpdateChapterName);
        }
        if self.lastUpdateChapterId != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.lastUpdateChapterId);
        }
        if self.lastUpdatetime != 0 {
            my_size += ::protobuf::rt::int64_size(10, self.lastUpdatetime);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.comicId != 0 {
            os.write_int64(1, self.comicId)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        if self.islong != 0 {
            os.write_int32(3, self.islong)?;
        }
        if !self.authors.is_empty() {
            os.write_string(4, &self.authors)?;
        }
        if !self.types.is_empty() {
            os.write_string(5, &self.types)?;
        }
        if !self.cover.is_empty() {
            os.write_string(6, &self.cover)?;
        }
        if !self.status.is_empty() {
            os.write_string(7, &self.status)?;
        }
        if !self.lastUpdateChapterName.is_empty() {
            os.write_string(8, &self.lastUpdateChapterName)?;
        }
        if self.lastUpdateChapterId != 0 {
            os.write_int64(9, self.lastUpdateChapterId)?;
        }
        if self.lastUpdatetime != 0 {
            os.write_int64(10, self.lastUpdatetime)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComicUpdateListInfo {
        ComicUpdateListInfo::new()
    }

    fn clear(&mut self) {
        self.comicId = 0;
        self.title.clear();
        self.islong = 0;
        self.authors.clear();
        self.types.clear();
        self.cover.clear();
        self.status.clear();
        self.lastUpdateChapterName.clear();
        self.lastUpdateChapterId = 0;
        self.lastUpdatetime = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComicUpdateListInfo {
        static instance: ComicUpdateListInfo = ComicUpdateListInfo {
            comicId: 0,
            title: ::std::string::String::new(),
            islong: 0,
            authors: ::std::string::String::new(),
            types: ::std::string::String::new(),
            cover: ::std::string::String::new(),
            status: ::std::string::String::new(),
            lastUpdateChapterName: ::std::string::String::new(),
            lastUpdateChapterId: 0,
            lastUpdatetime: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ComicUpdateListInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ComicUpdateListInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ComicUpdateListInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComicUpdateListInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bcomic.proto\"\x98\x02\n\x12ComicChapterDetail\x12\x1c\n\tchapterId\
    \x18\x01\x20\x01(\x03R\tchapterId\x12\x18\n\x07comicId\x18\x02\x20\x01(\
    \x03R\x07comicId\x12\x14\n\x05title\x18\x03\x20\x01(\tR\x05title\x12\"\n\
    \x0cchapterOrder\x18\x04\x20\x01(\x05R\x0cchapterOrder\x12\x1c\n\tdirect\
    ion\x18\x05\x20\x01(\x05R\tdirection\x12\x18\n\x07pageUrl\x18\x06\x20\
    \x03(\tR\x07pageUrl\x12\x16\n\x06picnum\x18\x07\x20\x01(\x05R\x06picnum\
    \x12\x1c\n\tpageUrlHD\x18\x08\x20\x03(\tR\tpageUrlHD\x12\"\n\x0ccommentC\
    ount\x18\t\x20\x01(\x05R\x0ccommentCount\"\xca\x01\n\x10ComicChapterInfo\
    \x12\x1c\n\tchapterId\x18\x01\x20\x01(\x03R\tchapterId\x12\"\n\x0cchapte\
    rTitle\x18\x02\x20\x01(\tR\x0cchapterTitle\x12\x1e\n\nupdateTime\x18\x03\
    \x20\x01(\x03R\nupdateTime\x12\x1a\n\x08fileSize\x18\x04\x20\x01(\x05R\
    \x08fileSize\x12\"\n\x0cchapterOrder\x18\x05\x20\x01(\x05R\x0cchapterOrd\
    er\x12\x14\n\x05isFee\x18\x06\x20\x01(\x05R\x05isFee\"m\n\x14ComicChapte\
    rResponse\x12\x14\n\x05errno\x18\x01\x20\x01(\x05R\x05errno\x12\x16\n\
    \x06errmsg\x18\x02\x20\x01(\tR\x06errmsg\x12'\n\x04data\x18\x03\x20\x01(\
    \x0b2\x13.ComicChapterDetailR\x04data\"O\n\x10ComicChapterList\x12\x14\n\
    \x05title\x18\x01\x20\x01(\tR\x05title\x12%\n\x04data\x18\x02\x20\x03(\
    \x0b2\x11.ComicChapterInfoR\x04data\"e\n\x13ComicDetailResponse\x12\x14\
    \n\x05errno\x18\x01\x20\x01(\x05R\x05errno\x12\x16\n\x06errmsg\x18\x02\
    \x20\x01(\tR\x06errmsg\x12\x20\n\x04data\x18\x03\x20\x01(\x0b2\x0c.Comic\
    DetailR\x04data\"\xb5\x07\n\x0bComicDetail\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\x03R\x02id\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x1c\
    \n\tdirection\x18\x03\x20\x01(\x05R\tdirection\x12\x16\n\x06islong\x18\
    \x04\x20\x01(\x05R\x06islong\x12\x16\n\x06isDmzj\x18\x05\x20\x01(\x05R\
    \x06isDmzj\x12\x14\n\x05cover\x18\x06\x20\x01(\tR\x05cover\x12\x20\n\x0b\
    description\x18\x07\x20\x01(\tR\x0bdescription\x12&\n\x0elastUpdatetime\
    \x18\x08\x20\x01(\x03R\x0elastUpdatetime\x124\n\x15lastUpdateChapterName\
    \x18\t\x20\x01(\tR\x15lastUpdateChapterName\x12\x1c\n\tcopyright\x18\n\
    \x20\x01(\x05R\tcopyright\x12\x20\n\x0bfirstLetter\x18\x0b\x20\x01(\tR\
    \x0bfirstLetter\x12\x18\n\x07comicPy\x18\x0c\x20\x01(\tR\x07comicPy\x12\
    \x16\n\x06hidden\x18\r\x20\x01(\x05R\x06hidden\x12\x16\n\x06hotNum\x18\
    \x0e\x20\x01(\x03R\x06hotNum\x12\x16\n\x06hitNum\x18\x0f\x20\x01(\x03R\
    \x06hitNum\x12\x10\n\x03uid\x18\x10\x20\x01(\x03R\x03uid\x12\x16\n\x06is\
    Lock\x18\x11\x20\x01(\x05R\x06isLock\x120\n\x13lastUpdateChapterId\x18\
    \x12\x20\x01(\x05R\x13lastUpdateChapterId\x12\x1f\n\x05types\x18\x13\x20\
    \x03(\x0b2\t.ComicTagR\x05types\x12!\n\x06status\x18\x14\x20\x03(\x0b2\t\
    .ComicTagR\x06status\x12#\n\x07authors\x18\x15\x20\x03(\x0b2\t.ComicTagR\
    \x07authors\x12\"\n\x0csubscribeNum\x18\x16\x20\x01(\x03R\x0csubscribeNu\
    m\x12-\n\x08chapters\x18\x17\x20\x03(\x0b2\x11.ComicChapterListR\x08chap\
    ters\x12\x20\n\x0bisNeedLogin\x18\x18\x20\x01(\x05R\x0bisNeedLogin\x12/\
    \n\x08urlLinks\x18\x19\x20\x03(\x0b2\x13.ComicDetailUrlLinkR\x08urlLinks\
    \x12$\n\risHideChapter\x18\x1a\x20\x01(\x05R\risHideChapter\x123\n\ndhUr\
    lLinks\x18\x1b\x20\x03(\x0b2\x13.ComicDetailUrlLinkR\ndhUrlLinks\x12\x1e\
    \n\ncornerMark\x18\x1c\x20\x01(\tR\ncornerMark\x12\x14\n\x05isFee\x18\
    \x1d\x20\x01(\x05R\x05isFee\":\n\x08ComicTag\x12\x14\n\x05tagId\x18\x01\
    \x20\x01(\x03R\x05tagId\x12\x18\n\x07tagName\x18\x02\x20\x01(\tR\x07tagN\
    ame\"O\n\x12ComicDetailUrlLink\x12\x14\n\x05title\x18\x01\x20\x01(\tR\
    \x05title\x12#\n\x04list\x18\x02\x20\x03(\x0b2\x0f.ComicDetailUrlR\x04li\
    st\"\xa8\x01\n\x0eComicDetailUrl\x12\x0e\n\x02id\x18\x01\x20\x01(\x03R\
    \x02id\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x10\n\x03url\
    \x18\x03\x20\x01(\tR\x03url\x12\x12\n\x04icon\x18\x04\x20\x01(\tR\x04ico\
    n\x12\x20\n\x0bpackageName\x18\x05\x20\x01(\tR\x0bpackageName\x12\x12\n\
    \x04dUrl\x18\x06\x20\x01(\tR\x04dUrl\x12\x14\n\x05btype\x18\x07\x20\x01(\
    \x05R\x05btype\"m\n\x15ComicRankListResponse\x12\x14\n\x05errno\x18\x01\
    \x20\x01(\x05R\x05errno\x12\x16\n\x06errmsg\x18\x02\x20\x01(\tR\x06errms\
    g\x12&\n\x04data\x18\x03\x20\x03(\x0b2\x12.ComicRankListInfoR\x04data\"\
    \x8a\x03\n\x11ComicRankListInfo\x12\x19\n\x08comic_id\x18\x01\x20\x01(\
    \x03R\x07comicId\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x18\
    \n\x07authors\x18\x03\x20\x01(\tR\x07authors\x12\x16\n\x06status\x18\x04\
    \x20\x01(\tR\x06status\x12\x14\n\x05cover\x18\x05\x20\x01(\tR\x05cover\
    \x12\x14\n\x05types\x18\x06\x20\x01(\tR\x05types\x12'\n\x0flast_updateti\
    me\x18\x07\x20\x01(\x03R\x0elastUpdatetime\x127\n\x18last_update_chapter\
    _name\x18\x08\x20\x01(\tR\x15lastUpdateChapterName\x12\x19\n\x08comic_py\
    \x18\t\x20\x01(\tR\x07comicPy\x12\x10\n\x03num\x18\n\x20\x01(\x03R\x03nu\
    m\x12\x15\n\x06tag_id\x18\x0b\x20\x01(\x05R\x05tagId\x12!\n\x0cchapter_n\
    ame\x18\x0c\x20\x01(\tR\x0bchapterName\x12\x1d\n\nchapter_id\x18\r\x20\
    \x01(\x03R\tchapterId\"e\n\x16RankTypeFilterResponse\x12\x14\n\x05errno\
    \x18\x01\x20\x01(\x05R\x05errno\x12\x16\n\x06errmsg\x18\x02\x20\x01(\tR\
    \x06errmsg\x12\x1d\n\x04data\x18\x03\x20\x03(\x0b2\t.ComicTagR\x04data\"\
    q\n\x17ComicUpdateListResponse\x12\x14\n\x05errno\x18\x01\x20\x01(\x05R\
    \x05errno\x12\x16\n\x06errmsg\x18\x02\x20\x01(\tR\x06errmsg\x12(\n\x04da\
    ta\x18\x03\x20\x03(\x0b2\x14.ComicUpdateListInfoR\x04data\"\xcb\x02\n\
    \x13ComicUpdateListInfo\x12\x18\n\x07comicId\x18\x01\x20\x01(\x03R\x07co\
    micId\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x16\n\x06islon\
    g\x18\x03\x20\x01(\x05R\x06islong\x12\x18\n\x07authors\x18\x04\x20\x01(\
    \tR\x07authors\x12\x14\n\x05types\x18\x05\x20\x01(\tR\x05types\x12\x14\n\
    \x05cover\x18\x06\x20\x01(\tR\x05cover\x12\x16\n\x06status\x18\x07\x20\
    \x01(\tR\x06status\x124\n\x15lastUpdateChapterName\x18\x08\x20\x01(\tR\
    \x15lastUpdateChapterName\x120\n\x13lastUpdateChapterId\x18\t\x20\x01(\
    \x03R\x13lastUpdateChapterId\x12&\n\x0elastUpdatetime\x18\n\x20\x01(\x03\
    R\x0elastUpdatetimeb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(14);
            messages.push(ComicChapterDetail::generated_message_descriptor_data());
            messages.push(ComicChapterInfo::generated_message_descriptor_data());
            messages.push(ComicChapterResponse::generated_message_descriptor_data());
            messages.push(ComicChapterList::generated_message_descriptor_data());
            messages.push(ComicDetailResponse::generated_message_descriptor_data());
            messages.push(ComicDetail::generated_message_descriptor_data());
            messages.push(ComicTag::generated_message_descriptor_data());
            messages.push(ComicDetailUrlLink::generated_message_descriptor_data());
            messages.push(ComicDetailUrl::generated_message_descriptor_data());
            messages.push(ComicRankListResponse::generated_message_descriptor_data());
            messages.push(ComicRankListInfo::generated_message_descriptor_data());
            messages.push(RankTypeFilterResponse::generated_message_descriptor_data());
            messages.push(ComicUpdateListResponse::generated_message_descriptor_data());
            messages.push(ComicUpdateListInfo::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
